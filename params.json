{
  "name": "PyMzn",
  "tagline": "A Python wrapper for the MiniZinc tool pipeline.",
  "body": "[PyMzn](https://github.com/paolodragone/PyMzn)\r\n==============================================\r\n\r\nPyMzn is a Python wrapper for the MiniZinc tool pipeline. <br/>\r\nIt is built on top of the libminizinc library (version 2.0) and provides a\r\nnumber of off-the-shelf functions to readily solve problems encoded in\r\nMiniZinc and parse the solutions into python objects.\r\n\r\nCurrently, PyMzn is developed and maintained in Python v3.5 with a porting to\r\nPython v2.7 at every release (without the most recent changes).\r\n\r\nInstall\r\n-------\r\n\r\nPyMzn requires some additional software to be installed on your system before\r\nyou can use it properly, namely:\r\n* The libminizinc library;\r\n* A CSP solver compatible with the FlatZinc encoding.\r\n\r\n### Install Libminizinc\r\n\r\nWhile you can install any bundled MiniZinc package, the minimal requirement to\r\nuse PyMzn is to install the libminizinc library. You can download the source\r\ncode of libminizinc from:\r\n<br/>\r\nhttps://github.com/MiniZinc/libminizinc/archive/master.zip\r\n<br/>\r\nInstructions on how to compile and install libminizinc are provided in the\r\nsource code. If you install libminizinc in a location different from the\r\ndefault one, then it is strongly recommended to insert the libminizinc binary\r\npath into the PATH environment variable, in order to avoid to configure it in\r\nPyMzn at each use.\r\n\r\n### Install Gecode\r\n\r\nThe next step is to install a CSP solver compatible with FlatZinc. You can\r\nuse any solver you like, but the default one for PyMzn is Gecode. If you use\r\nGecode as solver, PyMzn will work out-of-the-box, otherwise it will need some\r\nlittle configuration (more on this in section\r\n[Additional configuration](#config)).\r\n\r\nTo install Gecode v4.4.0, we recommend you to download and compile the source\r\ncode, since binary packages are usually less frequently updated. The source\r\ncode is available at:\r\n<br/>\r\nhttp://www.gecode.org/download/gecode-4.4.0.tar.gz\r\n<br/>\r\nInstruction on how to compile and install are found in the source package.\r\nAgain, it is recommended to either install in the default location otherwise\r\nto put the binary path of gecode into the PATH variable.\r\n\r\n### Install PyMzn\r\n\r\nAfter those preliminary steps, you can install PyMzn by either download the\r\nsource code from the [GitHub](https://github.com/paolodragone/PyMzn)\r\nrepository and include it in your project or install it through Pip:\r\n```\r\npip3 install pymzn\r\n```\r\nAdjust the version of Pip according to the python version you want to use.\r\n\r\nQuick Start\r\n-----------\r\n\r\nFirst, you need a MiniZinc model encoding the problem you want to solve. Here\r\nis a simple 0-1 knapsack problem encoded with MiniZinc:\r\n```\r\n%% test.mzn %%\r\n\r\nint: n = 5;\r\nset of int: OBJ = 1..n;\r\nint: capacity = 20;\r\narray[OBJ] of int: profit = [10, 3, 9, 4, 8];\r\narray[OBJ] of int: size = [14, 4, 10, 6, 9];\r\n\r\nvar set of OBJ: x;\r\nconstraint sum(i in x)(size[i]) <= capacity;\r\nvar int: obj = sum(i in x)(profit[i])\r\nsolve maximize obj;\r\n```\r\n\r\nYou can solve the above problem using the PyMzn `minizinc` function:\r\n```\r\nimport pymzn\r\npymzn.minizinc('test.mzn')\r\n```\r\nThe result will be:\r\n```\r\n[{'x': {3, 5}}]\r\n```\r\nThe `minizinc` function returns a list of solutions. The default behavior is\r\nto evaluate the solutions into python objects. Solutions are dictionaries\r\ncontaining variable assignments. The returned variables are, by default, the\r\n'free' variables, i.e. those that do not depend on other variables.\r\nIf you are interested in the value of other variables for each solution you\r\ncan specify the `output_vars` argument:\r\n```\r\npymzn.minizinc('test.mzn', output_vars=['x', 'obj'])\r\n```\r\nThis will override the default behavior so, if you are still interested in\r\nthe default set of variables, you need to specify them as well.\r\n\r\nThe evaluation of the solutions by PyMzn uses an internal output\r\nrepresentation (actually dzn format) specified as an output statement that\r\noverrides the one specified in the model if any (though the original output\r\nstatement in your model is left untouched, more details on how PyMzn works\r\ninternally are available in the documentation).\r\n\r\nIf you wish to override the default behavior and get as output strings\r\nformatted with your original output statement you can use the `raw_output`\r\nargument:\r\n```\r\npymzn.minizinc('test.mzn', raw_output=True)\r\n```\r\nThis will disable the automatic parsing, so the `output_vars` will be ignored\r\nif specified.\r\n\r\n### Data\r\nIt is possible to specify data (.dzn) files to the `minizinc` function as\r\nadditional positional arguments:\r\n```\r\npymzn.minizinc('test.mzn', 'data1.dzn', 'data2.dzn')\r\n```\r\nIt is also possible to specify additional data inline with the `minizinc`\r\nfunction:\r\n```\r\npymzn.minizinc('test.mzn', 'data1.dzn', 'data2.dzn', data={'n': 10, 'm': [1,3,5]})\r\n```\r\nWith the `data` argument you can specify an assignment of variables that will\r\nbe automatically converted to dzn format with the `pymzn.dzn` function (more\r\ndetails in the [Dzn files](#dzn) section).\r\n\r\n### Solver's arguments\r\nUsually, solvers provide arguments that can be used to modify their behavior.\r\nYou can specify arguments to pass to the solver as additional keyword\r\narguments in the `minizinc` function. For instance, using the argument `time`\r\nfor Gecode, it will set a time cut-off (in milliseconds) for the problem\r\nsolving.\r\n```\r\npymzn.minizinc('test.mzn', time=30000)  # 30 seconds cut-off\r\n```\r\nAdding the `parallel` argument, you can specify how many threads should Gecode\r\nuse for the problem solving:\r\n```\r\npymzn.minizinc('test.mzn', time=30000, parallel=0)  # 0 = number of available CPU cores\r\n```\r\nMore details on available options are in the documentation.\r\n\r\n<a name=\"config\"></a>\r\n\r\nAdditional configuration\r\n------------------------\r\nIf you want to specify custom paths to the MiniZinc or Gecode binaries you can\r\nset their values through the `pymzn.config` module.\r\n```\r\nimport pymzn.config\r\n\r\npymzn.config.mzn2fzn_cmd = path/to/mzn2fzn\r\npymzn.config.solns2out_cmd = path/to/solns2out\r\npymzn.config.gecode_cmd = path/to/fzn-gecode\r\n```\r\nThese settings persist throughout the execution of your application.\r\nThe `pymzn.config` module provides access to all the static settings of PyMzn.\r\n\r\nPyMzn can also be set to print debugging messages on standard output via:\r\n```\r\npymzn.debug()\r\n```\r\nThis function is meant to be used in interactive sessions or in applications\r\nthat do not configure the `logging` library. If you configure the `logging`\r\nlibrary in your application, then PyMzn will be affected as well. The logging\r\nlevel in PyMzn is always `DEBUG`.\r\nTo disable debugging messages you can then call:\r\n```\r\npymzn.debug(False)\r\n```\r\n\r\n<a name=\"solvers\"></a>\r\n\r\nSolvers\r\n-------\r\nIf you want to use a different solver other than Gecode, you first need to\r\nmake sure that it supports the FlatZinc input.\r\nTo solve your model through PyMzn using the selected solver, you need to\r\nuse a proxy function.\r\nPyMzn provides natively a number of solvers proxy functions. If the solver\r\nyour solver is not supported natively, you can use the generic proxy function\r\n`pymzn.solve`:\r\n```\r\npymzn.minizinc('test.mzn', fzn_fn=pymzn.solve, solver_cmd='path/to/solver')\r\n```\r\n\r\nIf you want to provide additional arguments and flexibility to the solver, you\r\ncan define your own proxy function. Here is an example:\r\n```\r\nfrom pymzn.binary import cmd, run\r\n\r\ndef my_solver(fzn_file, arg1=def_val1, arg2=def_val2):\r\n    solver = 'path/to/solver'\r\n    args = [('-arg1', arg1), ('-arg2', arg2), fzn_file]\r\n    return run(cmd(solver, args))\r\n```\r\nThen you can run the `minizinc` function like this:\r\n```\r\npymzn.minizinc('test.mzn', fzn_cmd=fzn_solver, arg1=val1, arg2=val2)\r\n```\r\n\r\n<a name=\"dzn\"></a>\r\n\r\nDzn files\r\n---------\r\nPyMzn provides a set of functions to deal with dzn encoded strings and files.\r\nUsing these functions it is possible to serialize Python objects into dzn\r\nformat and vice-versa. For instance, the `pymzn.dzn` function converts an\r\nassignment of variables (provided as a dictionary) into dzn format:\r\n```\r\npymzn.dzn({'a': 2, 'b': {4, 6}, 'c': {1, 2, 3}, 'd': {3: 4.5, 4: 1.3}, 'e': [[1, 2], [3, 4], [5, 6]]})\r\n```\r\nThe output is a list of dzn statements, as for the previous example:\r\n```\r\n['a = 2;', 'b = {4, 6};', 'c = 1..3;', 'd = array1d(3..4, [4.5, 1.3]);', 'e = array2d(1..3, 1..2, [1, 2, 3, 4, 5, 6];']\r\n```\r\n\r\nOptionally, you can pass the path to a dzn file where to write the statements.\r\n```\r\npymzn.dzn(data, fout='path/to/dzn')\r\n```\r\nThe supported types of python objects are:\r\n* Booleans\r\n* Integers\r\n* Floats\r\n* Sets\r\n* Multi-dimensional arrays:\r\n  * lists are converted into dzn arrays with index-set 1..len(list);\r\n  * dicts are converted into dzn arrays with index-set equal to the key-set\r\n    of the dict, provided that the index-set is contiguous;\r\n  * nested combinations of the previous two, provided that the children of\r\n    every node have the same index-set. The maximum depth is 6.\r\n\r\nTo parse back from dzn to python objects you can use the `pymzn.parse_dzn`\r\nfunction, which takes as input a dzn formatted string or path to a dzn file\r\nand returns the corresponding dictionary of variable assignments, for\r\ninstance, given the following dzn file:\r\n```\r\n%% test.dzn %%\r\n\r\na = 2;\r\nb = {4, 6};\r\nc = 1..3;\r\nd = array1d(3..4, [4.5, 1.3]);\r\ne = array2d(1..3, 1..2, [1, 2, 3, 4, 5, 6]);\r\n```\r\nRunning the function:\r\n```\r\npymzn.parse_dzn('test.dzn')\r\n```\r\nwill return:\r\n```\r\n{'a': 2, 'b': {4, 6}, 'c': {1, 2, 3}, 'd': {3: 4.5, 4: 1.3}, 'e': [[1, 2], [3, 4], [5, 6]]}\r\n```\r\nwhich is identical to the object we serialized in the previous example.\r\n\r\nIn general, there is a one to one translation from python objects to dzn and\r\nback, with the only exception of arrays with index-sets not based in 1.\r\nArrays and matrices based in 1 are translated into lists instead of\r\ndictionaries with explicit keys. For instance:\r\n```\r\npymzn.dzn({'a': {1: 2, 2: 4, 3: 6}})\r\n# returns: ['a = array1d(1..3, [2, 4, 6])']\r\n```\r\nbut when translating back the array, whose index-set is based in 1, will be\r\ntranslated into a list:\r\n```\r\npymzn.parse_dzn('a = array1d(1..3, [2, 4, 6])')\r\n# returns: {'a': [2, 4, 6]}\r\n```\r\nIf you wish to avoid this behavior and get all arrays as dictionaries then you\r\ncan specify `rebase_arrays=False` as argument for the `pymzn.parse_dzn`\r\nfunction.\r\n\r\nIf, instead, you want to rebase also the arrays and matrices with different\r\nindex-sets you can use the `pymzn.rebase_array` function, which will discard\r\nthe index-sets in the dictionary representation of the array (matrix) and\r\ntransform it into a list (list of lists). For instance:\r\n```\r\npymzn.rebase_array({3: {2: 1, 3: 2, 4: 3}, 4: {1: 2, 2: 3}})\r\n# returns: [[1, 2, 3], [2, 3]]\r\n```\r\n\r\nSerialization\r\n-------------\r\nAnother important aspect that PyMzn addresses is the \"isolation\" of solving\r\ninstances of a problem. This problem arises when there are multiple solving\r\ninstances of the same problem file running in parallel. This is especially\r\nimportant when the problems are continuously solved in separate threads.\r\nPyMzn can be set to make sure that the instances do not interfere with each\r\nother, by setting the argument `serialize=True` in the `minizinc` function.\r\nFor instance:\r\n```\r\nimport threading\r\n\r\ndef solve(n):\r\n    pymzn.minizinc('test.mzn', data={'n': n}, serialize=True)\r\n\r\nfor n in range(10):\r\n    threading.Thread(target=solve, args=(n,)).start()\r\n```\r\nSetting `serialize=True` in each solving instance will prevent all the\r\ninstances from interfering with each other.\r\n\r\nDynamic modelling\r\n-----------------\r\nPyMzn can also be used to dynamically change a model during runtime. For\r\nexample, it can be useful to add constraints incrementally or change the\r\nsolving statement dynamically.\r\nTo modify dynamically a model, you can use the class `MiniZincModel`, which\r\ncan take an optional model file as input and then can be modified by adding\r\nvariables and constraints, and by modifying the solve or output statements.\r\nAn instance of `MiniZincModel` can then be passed directly to the `minizinc`\r\nfunction to be solved.\r\n```\r\nmodel = pymzn.MiniZincModel('test.mzn')\r\n\r\nfor i in range(10):\r\n    model.add_constraint('arr_1[i] < arr_2[i]')\r\n    pymzn.minizinc(model)\r\n```\r\nAs you can see `MiniZincModel` is a mutable class which saves the internal\r\nstates and can be modified after every solving.\r\n\r\nTroubleshooting\r\n---------------\r\n* Gecode raises the following error at the first execution after the\r\n  installation:\r\n  ```\r\n  fzn-gecode: error while loading shared libraries: libgecodeflatzinc.so.41: cannot open shared object file: No such file or directory\r\n  ```\r\n  To solve this problem you need to set the environment variable\r\n  `LD_LIBRARY_PATH` before running your Python script:\r\n  ```\r\n  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib/\r\n  ```\r\n  or put the script into your `~/.bashrc` file and then run:\r\n  ```\r\n  source ~/.bashrc\r\n  ```\r\n\r\n* Minizinc raises the following error when trying to include the gecode library\r\n  with the `-G gecode` option:\r\n  ```\r\n  Cannot access include directory /usr/local/bin/../share/minizinc/gecode/\r\n  ```\r\n  To solve this problem you need to copy (or create links of) the files in the\r\n  directory `/usr/local/share/gecode/mznlib` into the directory `/usr/local/share/minizinc/gecode`.\r\n  ```\r\n  cd /usr/local/share\r\n  sudo mkdir minizinc/gecode\r\n  sudo cp gecode/mznlib/* minizinc/gecode/\r\n  ```\r\n\r\n* The function `pymzn.dzn` arises a `RecursionError` when given a `numpy.mat`\r\n  object as input. This problem arises because the iteration with `numpy.mat`\r\n  behaves differently than `numpy.ndarray` or built-in `list`. The simplest\r\n  solution is to convert the `numpy.mat` into a `numpy.ndarray`:\r\n  ```\r\n  matrix_array = np.asarray(matrix)\r\n  ```\r\n\r\nMaintainers\r\n-----------\r\n\r\n[Paolo Dragone](http://paolodragone.com), University of Trento\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}